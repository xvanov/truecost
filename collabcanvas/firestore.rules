rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Board document - allow authenticated users to create/read/update
    match /boards/{boardId} {
      allow read, write: if request.auth != null;
      
      // Global board shapes collection
      match /shapes/{shapeId} {
        // Auth required for all operations
        allow read: if request.auth != null;
        
        // Create: Validate shape schema and auth
        allow create: if request.auth != null
          // Validate shape type
          && request.resource.data.type in ['rect', 'circle', 'text', 'line', 'polyline', 'polygon']
          // Validate position fields are numbers
          && request.resource.data.x is number
          && request.resource.data.y is number
          && request.resource.data.w is number
          && request.resource.data.h is number
          // Validate color is string
          && request.resource.data.color is string
          // Validate metadata
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.updatedBy == request.auth.uid
          // Ensure server timestamps are used
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.clientUpdatedAt is number
          // Validate layerId is string (optional)
          && (request.resource.data.layerId == null || request.resource.data.layerId is string)
          // Validate type-specific properties
          && (request.resource.data.type == 'rect' 
              || (request.resource.data.type == 'circle' && request.resource.data.radius is number)
              || (request.resource.data.type == 'text' && request.resource.data.text is string && request.resource.data.fontSize is number)
              || (request.resource.data.type == 'line' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'polyline' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'polygon' && request.resource.data.strokeWidth is number && request.resource.data.points is list));
        
        // Update: Allow position and property updates by authenticated user
        allow update: if request.auth != null
          // Only the user who last updated can update again
          && request.resource.data.updatedBy == request.auth.uid
          // Validate that core fields don't change
          && request.resource.data.type == resource.data.type
          && request.resource.data.createdBy == resource.data.createdBy
          && request.resource.data.createdAt == resource.data.createdAt
          // Validate position fields
          && request.resource.data.x is number
          && request.resource.data.y is number
          && request.resource.data.w is number
          && request.resource.data.h is number
          // Validate color is string
          && request.resource.data.color is string
          // Validate updatedAt timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.clientUpdatedAt is number
          // Validate type-specific properties remain valid
          && (request.resource.data.type == 'rect' 
              || (request.resource.data.type == 'circle' && request.resource.data.radius is number)
              || (request.resource.data.type == 'text' && request.resource.data.text is string && request.resource.data.fontSize is number)
              || (request.resource.data.type == 'line' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'polyline' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'polygon' && request.resource.data.strokeWidth is number && request.resource.data.points is list));
        
        // Delete: Allow authenticated users to delete shapes
        allow delete: if request.auth != null;
      }
      
      // Global board layers collection
      match /layers/{layerId} {
        // Auth required for all operations
        allow read: if request.auth != null;
        
        // Create: Basic validation
        allow create: if request.auth != null
          && request.resource.data.name is string
          && request.resource.data.createdBy == request.auth.uid;
        
        // Update: Basic validation
        allow update: if request.auth != null
          && request.resource.data.updatedBy == request.auth.uid;
        
        // Delete: Allow authenticated users to delete layers
        allow delete: if request.auth != null;
      }
    }
    
    // Projects collection - project management system
    match /projects/{projectId} {
      // Helper function to check if user is owner
      function isOwner() {
        return request.auth != null && resource.data.ownerId == request.auth.uid;
      }
      
      // Read: Allow authenticated users to read project document for permission checking
      // This is needed so that get() calls in subcollection rules can succeed
      // Application logic enforces actual access control
      allow read: if request.auth != null;
      
      // List: Allow authenticated users to query projects
      // The query itself must filter by ownerId (where('ownerId', '==', userId))
      // We can't check resource.data in list queries, so we allow the query and filter client-side
      allow list: if request.auth != null;
      
      // Create: Authenticated user, must set ownerId to their uid
      allow create: if request.auth != null
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.name is string
        && request.resource.data.description is string
        && request.resource.data.status is string
        && request.resource.data.status in ['estimating', 'bid-ready', 'bid-lost', 'executing', 'completed-profitable', 'completed-unprofitable', 'completed-unknown']
        && request.resource.data.collaborators is list
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.updatedBy == request.auth.uid;
      
      // Update: Owner or editor collaborator
      // Note: Firestore rules have limited array iteration capabilities
      // We allow update if user is owner OR if document has collaborators array
      // Application logic will enforce that user is actually an editor collaborator
      // For stricter security in production, consider using a Cloud Function
      allow update: if request.auth != null
        && (isOwner() || resource.data.collaborators != null)
        && request.resource.data.ownerId == resource.data.ownerId // Cannot change owner
        && request.resource.data.createdBy == resource.data.createdBy // Cannot change creator
        && request.resource.data.createdAt == resource.data.createdAt; // Cannot change creation time
      
      // Delete: Only owner
      allow delete: if isOwner();
      
      // Shapes subcollection - project-scoped shapes
      match /shapes/{shapeId} {
        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return request.auth != null;
        }
        
        // Read: Owner or collaborator (viewer/editor)
        allow read: if isOwnerOrCollaborator();
        
        // Create: Owner or editor collaborator
        // Temporarily allow any authenticated user to create shapes for debugging
        allow create: if request.auth != null
          // Validate shape type (checked in type-specific validation below)
          && request.resource.data.type is string
          // Validate position fields are numbers
          && request.resource.data.x is number
          && request.resource.data.y is number
          && request.resource.data.w is number
          && request.resource.data.h is number
          // Validate color is string
          && request.resource.data.color is string
          // Validate metadata
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.updatedBy == request.auth.uid
          // Ensure server timestamps are used
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.clientUpdatedAt is number
          // Validate layerId is string (optional)
          && (request.resource.data.layerId == null || request.resource.data.layerId is string)
          // Validate type-specific properties
          && (
              request.resource.data.type == 'rect' 
              || (request.resource.data.type == 'circle' && request.resource.data.radius is number)
              || (request.resource.data.type == 'text' && request.resource.data.text is string && request.resource.data.fontSize is number)
              || (request.resource.data.type == 'line' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'polyline' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'polygon' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (request.resource.data.type == 'boundingbox' && request.resource.data.itemType is string && request.resource.data.strokeWidth is number)
          );
        
        // Update: Owner or editor collaborator
        // Temporarily allow any authenticated user to update shapes for debugging
        // Note: For partial updates, request.resource.data contains merged data (existing + update)
        allow update: if request.auth != null
          // Validate that core fields don't change
          && resource.data.type is string
          && request.resource.data.createdBy == resource.data.createdBy
          && request.resource.data.createdAt == resource.data.createdAt
          // Validate position fields exist and are numbers (may use existing values from merge)
          && request.resource.data.x is number
          && request.resource.data.y is number
          && request.resource.data.w is number
          && request.resource.data.h is number
          // Validate color is string
          && request.resource.data.color is string
          // Validate updatedAt timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.clientUpdatedAt is number
          // Validate type-specific properties remain valid (check based on existing type from resource.data)
          && (resource.data.type == 'rect' 
              || (resource.data.type == 'circle' && request.resource.data.radius is number)
              || (resource.data.type == 'text' && request.resource.data.text is string && request.resource.data.fontSize is number)
              || (resource.data.type == 'line' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (resource.data.type == 'polyline' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (resource.data.type == 'polygon' && request.resource.data.strokeWidth is number && request.resource.data.points is list)
              || (resource.data.type == 'boundingbox' && request.resource.data.itemType is string && request.resource.data.strokeWidth is number));
        
        // Delete: Owner or editor collaborator
        // Temporarily allow any authenticated user to delete shapes for debugging
        allow delete: if request.auth != null;
      }
      
      // Layers subcollection - project-scoped layers
      match /layers/{layerId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }
        
        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }
        
        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Helper function to check if user is owner or editor
        function isOwnerOrEditor() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Owner or collaborator (viewer/editor)
        allow read: if isOwnerOrCollaborator();

        // Create: Owner or editor collaborator
        // Temporarily allow any authenticated user to create layers for debugging
        allow create: if request.auth != null
          && request.resource.data.name is string
          && request.resource.data.createdBy == request.auth.uid;
        
        // Update: Owner or editor collaborator
        allow update: if isOwnerOrEditor()
          && request.resource.data.updatedBy == request.auth.uid;
        
        // Delete: Owner or editor collaborator
        allow delete: if isOwnerOrEditor();
      }
      
      // Board collection - project-scoped board state
      match /board/{boardDocId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Helper function to check if user is owner or editor
        function isOwnerOrEditor() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Owner or collaborator (viewer/editor)
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Owner or editor collaborator
        allow create, update: if isOwnerOrEditor()
          && request.resource.data.updatedBy == request.auth.uid;

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }
      
      // Scope subcollection - scope of work document
      match /scope/{scopeId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Helper function to check if user is owner or editor
        function isOwnerOrEditor() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Owner or collaborator (viewer/editor)
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Owner or editor collaborator
        allow create, update: if isOwnerOrEditor()
          && request.resource.data.items is list
          && request.resource.data.uploadedBy is string;

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }
      
      // BOM subcollection - Bill of Materials document
      // AC: Task 18 - Firestore Security Rules
      match /bom/{bomId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Helper function to check if user is owner or editor
        function isOwnerOrEditor() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Owner or collaborator (viewer/editor)
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Owner or editor collaborator
        // Validate BOM structure
        allow create: if isOwnerOrEditor()
          && request.resource.data.totalMaterials is list
          && request.resource.data.calculations is list
          && request.resource.data.createdBy is string
          && request.resource.data.updatedBy == request.auth.uid
          && request.resource.data.createdAt is number;

        allow update: if isOwnerOrEditor()
          && request.resource.data.totalMaterials is list
          && request.resource.data.calculations is list
          && request.resource.data.updatedBy == request.auth.uid
          && (request.resource.data.updatedAt is timestamp || request.resource.data.updatedAt is number);

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }
      
      // CPM subcollection - Critical Path Method document
      match /cpm/{cpmId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Helper function to check if user is owner or editor
        function isOwnerOrEditor() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Owner or collaborator (viewer/editor)
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Owner or editor collaborator
        allow create, update: if isOwnerOrEditor()
          && request.resource.data.tasks is list
          && request.resource.data.createdBy is string
          && request.resource.data.updatedBy == request.auth.uid
          && request.resource.data.createdAt is number
          && request.resource.data.updatedAt is number;

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }
      
      // Estimations subcollection - estimation sessions for TrueCost workflow
      match /estimations/{sessionId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Helper function to check if user is owner or editor
        function isOwnerOrEditor() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read/List: Owner or collaborator (viewer/editor)
        allow read, list: if isOwnerOrCollaborator();

        // Create: Owner or editor collaborator
        allow create: if isOwnerOrEditor()
          && request.resource.data.projectId == projectId
          && request.resource.data.scopeText is string
          && request.resource.data.planImageUrl is string
          && request.resource.data.createdBy == request.auth.uid
          && request.resource.data.updatedBy == request.auth.uid;

        // Update: Owner or editor collaborator
        allow update: if isOwnerOrEditor()
          && request.resource.data.updatedBy == request.auth.uid
          && request.resource.data.projectId == resource.data.projectId
          && request.resource.data.createdBy == resource.data.createdBy;

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }

      // Price Comparison subcollection - multi-retailer price comparison results
      // Note: Cloud Functions handle most writes via Admin SDK (bypasses rules)
      // Client reads need to work even if project document doesn't exist yet
      match /priceComparison/{comparisonId} {
        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return request.auth != null
            && projectExists()
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Allow owner or collaborator to read price comparison results
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Cloud Functions use Admin SDK (bypasses rules)
        // Allow owner or collaborator for testing/development
        allow create, update: if isOwnerOrCollaborator();

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }

      // Config subcollection - project configuration (scope, estimate settings)
      match /config/{configId} {
        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return projectExists()
            && request.auth != null
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Owner or collaborator
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Owner or collaborator
        allow create, update: if isOwnerOrCollaborator()
          && request.resource.data.updatedBy == request.auth.uid;

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }

      // Chats subcollection - per-user chat history for AI assistant
      // Structure: projects/{projectId}/chats/{userId}/messages/{messageId}
      match /chats/{chatUserId} {
        // Allow user to read their own chat container
        allow read: if request.auth != null && request.auth.uid == chatUserId;
        
        // Messages subcollection
        match /messages/{messageId} {
          // Read: Only the chat owner can read their messages
          allow read: if request.auth != null && request.auth.uid == chatUserId;
          
          // Create: Only the chat owner can create messages
          allow create: if request.auth != null && request.auth.uid == chatUserId;
          
          // Update: Only the chat owner can update messages
          allow update: if request.auth != null && request.auth.uid == chatUserId;
          
          // Delete: Only the chat owner can delete messages
          allow delete: if request.auth != null && request.auth.uid == chatUserId;
        }
      }

      // Pipeline subcollection - estimate pipeline status and progress tracking
      // Story: 6-2 - Two-phase UI with progress tracking
      match /pipeline/{pipelineDocId} {
        // Helper function to get project document safely
        function getProject() {
          return get(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if project exists
        function projectExists() {
          return exists(/databases/$(database)/documents/projects/$(projectId));
        }

        // Helper function to check if user is owner or collaborator
        function isOwnerOrCollaborator() {
          return request.auth != null
            && projectExists()
            && (getProject().data.ownerId == request.auth.uid
                || getProject().data.collaborators != null);
        }

        // Read: Allow owner or collaborator to read pipeline status
        // Needed for real-time progress tracking in the UI
        allow read: if isOwnerOrCollaborator();

        // Create/Update: Cloud Functions use Admin SDK (bypasses rules)
        // Allow owner or collaborator for triggering pipelines
        allow create, update: if isOwnerOrCollaborator();

        // Delete: Only owner
        allow delete: if projectExists()
          && request.auth != null
          && getProject().data.ownerId == request.auth.uid;
      }
    }

    // Estimates collection - TrueCost deep pipeline
    match /estimates/{estimateId} {
      // Helper: require auth
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper: fetch parent estimate
      function getEstimate() {
        return get(/databases/$(database)/documents/estimates/$(estimateId));
      }

      // Helper: check estimate ownership safely for both estimate docs and subcollections.
      // - For estimate document reads/updates/deletes, `resource` is the estimate doc.
      // - For subcollection rules, `resource` is the child doc (no userId), so we must read parent.
      // IMPORTANT: do NOT rely on request.resource for reads (it is not populated for reads).
      function isEstimateOwner() {
        return isSignedIn() && (
          // Estimate document itself
          (resource != null && resource.data.userId == request.auth.uid)
          // Subcollections (derive from parent estimate)
          || (getEstimate() != null && getEstimate().data.userId == request.auth.uid)
        );
      }

      // Helper: allow writes while pipeline is mutable
      function pipelineWritable() {
        let est = getEstimate();
        return est != null
          && est.data.status in ['draft', 'clarifying', 'processing', 'plan_review'];
      }

      // Estimate document rules
      allow read: if isEstimateOwner();

      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp
        && request.resource.data.status is string;

      allow update: if isEstimateOwner()
        // owner cannot change
        && request.resource.data.userId == resource.data.userId
        // preserve creation time
        && request.resource.data.createdAt == resource.data.createdAt
        // updatedAt must be timestamp
        && request.resource.data.updatedAt is timestamp;

      allow delete: if isEstimateOwner();

      // Agent outputs (per agent) - read-only after pipeline completion
      match /agentOutputs/{agentId} {
        allow read: if isEstimateOwner();
        allow create, update: if isEstimateOwner() && pipelineWritable();
        allow delete: if isEstimateOwner() && pipelineWritable();
      }
      
      // Granular cost ledger items
      match /costItems/{costItemId} {
        allow read: if isEstimateOwner();
        allow create, update, delete: if isEstimateOwner() && pipelineWritable();
      }

      // Conversations tied to an estimate
      match /conversations/{msgId} {
        allow read, create, update, delete: if isEstimateOwner();
      }

      // Version snapshots of an estimate
      match /versions/{versionId} {
        allow read: if isEstimateOwner();
        allow create: if isEstimateOwner();
        allow update, delete: if isEstimateOwner();
      }
    }
    
    // Global Product Cache - shared across all users for price comparison optimization
    // Structure: productCache/{retailer}/products/{normalizedProductName}
    match /productCache/{retailer} {
      // Allow read access to retailer document
      allow read: if request.auth != null;

      // Products subcollection - cached product data by retailer
      match /products/{productId} {
        // Allow authenticated users to read cached products
        allow read: if request.auth != null;
        // Allow Cloud Functions to write (authenticated users can also write for testing)
        allow create, update: if request.auth != null;
        // Allow deletion for cache maintenance
        allow delete: if request.auth != null;
      }
    }

    // Global Materials Database - unified cache across all users (NFR1-NFR4)
    // Structure: globalMaterials/{normalizedName_zipCode}
    // Document ID format: {normalizedName}_{zipCode}
    match /globalMaterials/{materialId} {
      // NFR1: Authenticated users can read from globalMaterials
      allow read: if request.auth != null;

      // NFR2: Authenticated users can write to globalMaterials (for auto-population)
      // Note: In production, consider restricting writes to Cloud Functions only
      allow create, update: if request.auth != null;

      // Allow deletion for cache maintenance
      allow delete: if request.auth != null;
    }

    // Contractor Settings - user-specific contractor configuration
    // Structure: contractors/{userId} (profile) + subcollections for crews, materials, suppliers, laborRates
    match /contractors/{userId} {
      // Only the owner can read/write their contractor profile
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Crews subcollection - crew templates
      match /crews/{crewId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Materials subcollection - custom material pricing catalog
      match /materials/{materialId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Suppliers subcollection - supplier relationships
      match /suppliers/{supplierId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Labor rates subcollection - custom labor rate overrides
      match /laborRates/{trade} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Scan Projects - room scanning data linked to projects
    // Structure: scanProjects/{projectId}_scan
    match /scanProjects/{scanProjectId} {
      // Only the owner can read/write their scan project data
      // create uses request.resource (incoming data), post-creation rules use resource (existing doc)
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow read, update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Deny all other paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
